/*###############################################################
## MODULE: relque.cpp
## VERSION: 1.0 
## SINCE 2015-10-13
## AUTHOR Jimmy Lin (xl5224) - JimmyLin@utexas.edu  
## DESCRIPTION: 
##      
#################################################################
## Edited by MacVim
## Class Info auto-generated by Snippet 
################################################################*/

using namespace std;
#include <iostream>
#include <vector>
#include <unordered_map>
#include <float.h>

double getER (long id, vector< vector<long> >& related, vector<long>& T, long except) {
    long selfT = T[id];
    double accT = 0;
    long nNeighbors = related[id].size();
    if (nNeighbors == 1 and except != -1) // leaf node
        return 1.0*T[id];
    for (long i = 0; i < nNeighbors; i++) {
        if (related[id][i] != except) {
           accT += 1.0*getER (related[id][i], related, T, id);
        }
    }
    // non-leaf root visit
    if (except == -1) return 1.0*(T[id] + accT/nNeighbors);
    // non-leaf multiple children visit
    else return 1.0*(T[id] + 1.0*accT / (nNeighbors-1));
}

int main (int argn, char** argv) {
    long N; // length of given string;
    cin >> N;
    if (N < 0) return -1;
    vector<long> T (N, 0); // reading time
    vector< vector<long> > related (N, vector<long>());
    for (long i = 0; i < N; i++) 
        cin >> T[i];
    long Q1, Q2;
    while (cin >> Q1 >> Q2) {
        related[Q1-1].push_back(Q2-1);
        related[Q2-1].push_back(Q1-1);
    }
    // resolve the minimality
    double min_ER = DBL_MAX; 
    long min_ER_ID = -1;
    for (long i = 0; i < N; i++) {
        if (ER[i] <= min_ER) {
            min_ER = ER[i];
            min_ER_ID = i;
        }
    }
    cout <<  min_ER_ID + 1 << endl;
    return 0;
    }
